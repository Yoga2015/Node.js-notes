### 同源策略

**何为同源策略？**

​		协议、域名、端口号三者都相同就为同源，是由Netscape提出的一个著名的安全策略。同源策略（SOP）就是规定了 **不同  域  之间访问的策略**。

​    	首先你要对  **域**  有所了解，它就是  **协议 : // 域名 : 端口** ，不同的域下面存了不同的数据，例如cookie等，你发起同源请求肯定会带上本域的cookie，**访问其他网站的接口，发起跨域请求的时候，cookie默认不会带上去的**。同时本页面的域，页面会限制你只能看到自己域下的数据。同时跨域发送请求是没问题的，但是跨域返回的结果是不能加载的 , 原因就是不安全 , ajax请求受SOP限制。

**策略主要限制 js 的能力**

1.无法读取非同源的 cookie、Storage、indexDB的内容

2.无法读取非同源的DOM

3.无法发送非同源的[AJAX](https://so.csdn.net/so/search?q=AJAX&spm=1001.2101.3001.7020)，更加准确的说应该是**发送了请求但被浏览器拦截了，也就是说浏览器会拦截非同源的请求。**

   	浏览器肯定有跨域请求加载资源的需求了，比如 “加载其他域下的 资源”  ，例如：图片，css，js库 等，这些通过img、 link、 script 等标签去加载。这些都不算违背SOP。如果你要跨域访问接口，有很多种方法，例如cors，jsonp，代理等等。

​		**为什么要有同源策略 ？**其中一个重要原因就是对cookie的保护，cookie 中存着sessionID 。黑客一旦获取了sessionID 并且在有效期内 就可以登录，这里我们可以简单的认为sessionID 全等于 账户加密码，想想当我们访问了一个恶意网站 如果没有同源策略 那么这个网站就能通过js 访问document.cookie 得到用户关于的各个网站的sessionID 其中可能有 银行网站 、qq.com、github .com

1.为了防止恶意网页可以获取其他网站的本地数据。

2.为了防止恶意网站[iframe](https://so.csdn.net/so/search?q=iframe&spm=1001.2101.3001.7020)其他网站的时候，获取数据。

3.为了防止恶意网站在自已网站有访问其他网站的权利，以免通过cookie免登，拿到数据。

cookie、localStorage 和 indexDB 含有用户的信息，浏览器必须要防止不同的站点间去夺取对方的cookie信息，那么这就是浏览器的同源策略。如果没有同源策略，不同源的数据和资源（如HTTP头、Cookie、DOM、localStorage等）就能相互随意访问，根本没有隐私和安全可言。为了安全起见和资源的有效管理，浏览器当然要采用这种策略。

<img src="F:\Typora\typora-user-images\image-20220310142244906.png" alt="image-20220310142244906" style="zoom: 33%;" />

<img src="F:\Typora\typora-user-images\image-20220310142448985.png" alt="image-20220310142448985" style="zoom: 50%;" />

<img src="F:\Typora\typora-user-images\image-20220310143115416.png" alt="image-20220310143115416" style="zoom: 33%;" />



跨域问题

现在开发前后端分离，和使用服务商数据时，导致前端页面地址和后端API不是同源的，例如前端地址为baidu.com,后端API为api.baidu.com。直接访问API会触发[同源策略](https://so.csdn.net/so/search?q=同源策略&spm=1001.2101.3001.7020)，所以需要想办法跨过去。

##### 常见的跨域方法的原理

1.CORS

 CORS（跨域资源共享）使用专用的HTTP头，服务器（api.baidu.com）告诉浏览器，特定URL（baidu.com）的ajax请求可以直接使用，不会激活同源策略。

2.JSONP

 因为js调用（实际上是所有拥有src属性的 <\script>、<\img>、<\iframe>）是不会经过同源策略，例如baidu.com引用了CDN的jquery。所以我通过调用js脚本的方式，从服务器上获取JSON数据绕过同源策略。

只有xhr的请求方式才有可能产生跨域问题，所以不会产生跨域问题

3.nginx反向代理

 当你访问baidu.com/api/login的时候，通过在baidu.com的nginx服务器会识别你是api下的资源，会自动代理到api.baidu.com/login，浏览器本身是不知道我实际上是访问的api.baidu.com的数据，和前端资源同源，所以也就不会触发浏览器的同源策略。



#### 内置模块  - Jsonp 跨域方法

​	Jsonp （JSON with Padding ）是 json 的一种“使用模式”，可以让网页从别的域名（网站）那获取资料，即**跨域读取数据**。（已经安装 nodemon）  https://www.bootcdn.cn/

![image-20220207140246163](F:\Typora\typora-user-images\image-20220207140246163.png)

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>jsonp</title>
</head>
<body>
   <script>
       function getData(data){  //getData是随意起的名
           console.log(data)
       }
   </script> 

   <script src="http://localhost:8080/api/data"></script>
   <!-- <script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.js"></script> -->
</body>
</html>
```

```typescript
//1
const http = require('http');

const server = http.createServer((request,response)=>{
    let url = request.url;
    switch(url){
        case '/api/data':
        response.write("hello");
        break;
        default:
            response.write("page not found 404");
        
    }
    response.end();
})

server.listen(8080,()=>{
    console.log("localhost:8080")
})
```

![image-20220220120453154](F:\Typora\typora-user-images\image-20220220120453154.png)

这个接口 可以作为前端请求的接口，请求 http://localhost:8080/api/data 这个地址，这个script一执行就会把我们那个server.js拿过来直接在浏览器上run.

同样路径下，新起一个powershell  执行   npx http-server -p 9000   ？



#### 内置模块  - Jsonp 跨域

jsonp ：就是json padding ,  json 数据 填充

```typescript
 switch(url){
        case '/api/data':
        response.write("getData('hello')");
        break;
        default:
            response.write("page not found 404");
        
    }

再次请求 http://localhost:8080/api/data 这个地址，浏览器返回 getData('hello') ，这个填充称之为jsonp
```

```typescript
//2
const http = require('http')
const url = require('url')

const server = http.createServer((request, response) => {

    let urlStr = request.url;
    let urlObj =  url.parse(urlStr,true)

    switch (urlObj.pathname) {
        case '/api/data':
            response.write('${urlObj.query.cb}("hello")')
            break;
        default:
            response.write('page not found')
    }
    response.end()
}) 

server.listen(8080, () => {
    console.log('localhost:8080')
})
```

![image-20220208211327120](F:\Typora\typora-user-images\image-20220208211327120.png)

```
http://localhost:8080       显示 page not found
```

```
http://localhost:8080/api/data   显示hello
```

到这里等于自己封装了一个jsonp。

#### jsonp总结 

1. jsonp是一种跨域方案，他利用`script`标签没有跨域限制的特点，通过`script`标签的的src属性发送`GET`请求。

2. 可以通过前后端约定一个字段名，比如callback，来传递一个函数名，从而使得前端可以使用对应的callback函数，拿到数据，处理数据。

   npx http-server -p 9000          lsof -i:9000  就可以在我的系统里查找9000端口号被哪个进程给占了

   

#### 内置模块 - CORS  跨域

CORS：（跨域资源共享 Cross-origin resource sharing），它允许浏览器向跨域服务器发出XMLHttpRequest请求，从而克服跨域问题，它需要浏览器和服务器的同时支持。

1、浏览器端会自动向请求头添加origin字段，表明当前请求来源。
2、浏览器端需要设置响应头的Access-Control-Allow-Methods，Access-Control-Allow-Headers，Access-3、Control-Allow-Origin等字段，指定允许的方法，头部，源等信息。
请求分为简单请求和非简单请求，非简单请求会先进行一次OPTION方法进行预检，看是否允许当前跨域请求。

**1、例子：新建一个server2.js，并启动 node server2.js**

```typescript
var http = require('http');

http.createServer(function (request, response) {
    response.writeHead(200, {
      'Content-Type': 'text/plain',
    //  'Access-Control-Allow-Origin': '*'
    });
    response.end('request arrive');
}).listen(516);

console.log('Server running at http://127.0.0.1:516/');

```

**2、打开一个安全性较低的网站（任意一个） 直接在console中输入：**

```
let url = 'http://127.0.0.1:516/';
let xhr = new XMLHttpRequest();
xhr.open('GET', url, true);
xhr.send();
```

控制台立即**报CORS跨域问题**

![image-20220209161125999](F:\Typora\typora-user-images\image-20220209161125999.png)

**在node代码（server2.js）中加入**：     'Access-Control-Allow-Origin': '*'       谁访问我，我都给数据，

但这里有一个问题就是 跨域请求的话，涉及到携带token的问题 ，所以在前端还需要做一些配置

 **再次发送请求**就**已有响应**

```typescript
const http = require('http')
const url = require('url')

const server = http.createServer((request, response) => {
    // url 和上面同名了，所以改了urlStr
    let urlStr = request.url;
    let urlObj =  url.parse(urlStr,true)
    // 4
    switch (urlObj.pathname) {
        case '/api/data':
            response.writeHead(200,{
                "content-type":"application/json",
                "Access-Control-Allow-Origin":"*"
            })
            response.write('{"ret":true,"data":"hello"}')
            break;
        default: 
            response.write('page not found')
    }
    response.end()
}) 

server.listen(8080, () => {
    console.log('localhost:8080')
})


```

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>cors</title>
</head>
<body>
    <script>
        fetch('http://localhost:8080/api/data')
        .then(response =>response.json())
        .then(result =>{
            console.log(result)
        })
    </script>
    
</body>
</html>
```

先执行 nodemon server.js    ，在执行 npx http-server -p 9000   , 在浏览器输入http://localhost:9000/

![image-20220220130852871](F:\Typora\typora-user-images\image-20220220130852871.png)

这是cors 基本原理，未来还是用工具来实现 cors 跨域资源共享 

#### jsonp和cors比较

JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据